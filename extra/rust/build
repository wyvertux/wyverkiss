#!/bin/sh -e

patch -p1 < llvm-clang.patch

cat >> config.toml <<EOF
[llvm]
link-shared = true

[build]
EOF

if kiss l rust 2>/dev/null; then
cat >> config.toml <<EOF
rustc = "/usr/bin/rustc"
cargo = "/usr/bin/cargo"
EOF
else
    # Man, this is ugly. But it'll do.
    # The libgcc_s.so here are ripped directly from KISS' GCC 9.2.0 from
    # their chroot. It's only needed for the bootstrap tarball, basically.
    kiss l libgcc-bin >/dev/null 2>&1 || {
        echo "Please install libgcc-bin for bootstrapping Rust. It will be"
        echo "uninstalled immediately after the Rust build is successful."
        echo "I'm sorry for this terrible hack."
        false
    }

    # This package mimics the download process of rust's 'x.py'
    # bootstrap library to allow for the removal of the internet
    # connection requirement per build.
    {
        cache_dir=build/cache/2019-12-19
        mkdir -p "$cache_dir"

        for tarball in *.tar.xz\?no-extract; do
            mv -f "$tarball" "$cache_dir/${tarball%%\?no-extract}"
        done
    }
fi

cat >> config.toml <<EOF
build = "x86_64-unknown-linux-musl"
host = [ "x86_64-unknown-linux-musl" ]
target = [ "x86_64-unknown-linux-musl" ]
docs = false
extended = true
submodules = false
python = "python3"
locked-deps = true
vendor = true

[install]
prefix = "/usr"

[rust]
channel = "stable"
rpath = false
codegen-units = 1
debuginfo-level = 0
backtrace = false
jemalloc = false
codegen-tests = false
llvm-libunwind = true

[target.x86_64-unknown-linux-musl]
cc = "clang"
cxx = "clang++"
linker = "clang"
llvm-config = "/usr/bin/llvm-config"
crt-static = false
EOF

python3 ./x.py build -j "$(nproc)"
DESTDIR="$1" python3 ./x.py install
